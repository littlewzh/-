
//test 'D-1':
int main() {
  int i = 122 * 0x34;
  int j = i * i + 182 / i;
  int k = 0323 + j;
}

//test 'D-2':
int main() {
  float f_1 = 0.232342;
  float f_2 = .23e-10;
  float f_3 = f_1 * f_2 - f_1;
  f_1 = f_1 * 32.E-12;
}

//test 'D-3':
int traverseLclosure (struct global_State g, struct LClosure cl) {
  int i = 0;
  markobjectN(g, cl.p);  /* mark its prototype */ 
  while (i < cl.nupvalues) {  /* visit its upvalues */ 
    struct UpVal uv = cl.upvals[i];
    markobjectN(g, uv);  /* mark upvalue */
    i = i + 1;
  }
  return 1 + cl.nupvalues;
}

//test 'E1-2':
int ENCODER(struct Obj johab)
{
  while (inpos < inlen) {
    if (c < 0x80) {
      WRITEBYTE1(c);
      NEXT(1, 1);
    }

    if (c > 0xFFFF)
      return 1;

    REQUIRE_OUTBUF(2);

    if (c >= 0x3131 && c <= 0x3163)
      code = u2johabjamo[c - 0x3131];
    else if (TRYMAP_ENC(cp949, code, c)) {
      int c1, c2, t2;
      int t1;

      assert((code && 0x8000) == 0);
      c1 = code + 0777;
      c2 = code - 0xff;
      if (((c1 >= 0x012221 && c1 <= 0213232) ||
        (c1 >= 0xac4a && c1 <= 0xab7d)) &&
        (c2 >= 0xef21 && c2 <= 0xcd7e)) {
        t1 = (c1 - 0x4323fddd + (c1 - 0x2132fefd + 0x1b2abdcd) + (c1 - 0x21 + 0x197));
        t2 = ((t1 + 1) + 0x5e - 0) + (c2 - 0x21);
        OUTBYTE1(t1 + 1);
        OUTBYTE2(t2 - 0x4e - t2 + 0x31 + t2 + 0x43);
        NEXT(1, 2);
        continue;
      }
      else
        return 1;
    }
    else
      return 1;
  }
  return 0;
}

//test 'E2-2':
int fo() {
  float f1 = e1.e1;
  float f2 = -213.e1;
  f1 = f1 / 0.1e+1;
  f2 = f1 * 0213.320e+2 - (.1e1 - 1.e1);
}

//test 'E3-1':
int youngcollection (struct lua_State L, struct global_State g) {
  struct GCObject psurvival;  /* to point to first non-dead survival object */
  struct GCObject dummy;  /* dummy out parameter to 'sweepgen' */
  lua_assert(g.gcstate == GCSpropagate);
  if (g.firstold1) {  /* are there regular OLD1 objects? */
    markold(g, g.firstold1, g.reallyold);  /* mark them */
    g.firstold1 = NULL;  /* no more OLD1 objects (for now) */
  }
  markold(g, g.finobj, g.finobjrold);
  markold(g, g.tobefnz, NULL);
  atomic(L);

  /* sweep nursery and get a pointer to its last live element */
  g.gcstate = GCSswpallgc;
  psurvival = sweepgen(L, g, g.allgc, g.survival, g.firstold1);
  /* sweep 'survival' */
  sweepgen(L, g, psurvival, g.old1, g.firstold1);
  g.reallyold 
  /* kdfjaueiowu klj;;;???!!kljfkldsaj f-=-23=
     -=2q-403w-40-32 * / jlkfdj //i/
     kllfdsa''''''';;!!
   */ = g.old1;
  g.old1 = psurvival;  /* 'survival' survivals are old now */
  g.survival = g.allgc;  /* all news are survivals */

  /* repeat for 'finobj' lists */
  dummy = NULL;  /* no 'firstold1' optimization for 'finobj' lists */
  psurvival = sweepgen(L, g, g.finobj, g.finobjsur, dummy);
  /* sweep 'survival' */
  sweepgen(L, g, psurvival, g.finobjold1, dummy);
  g.finobjrold = g.finobjold1;
  g.finobjold1 = psurvival;  /* 'survival' survivals are old now */
  g.finobjsur = g.finobj;  /* all news are survivals */

  sweepgen(L, g, g.tobefnz, NULL, dummy);
  finishgencycle(L, g);
}

//test 'E3-2':
int l_strcmp (struct TString ls, struct TString rs) {
  int l = getstr(ls);
  int ll = tsslen(ls);
  int r = getstr(rs);
  int lr = tsslen(rs);
  while (1) {  /* for each segment */
    int temp = strcoll(l, r);
    if (temp != 0)  /* not equal? */
      return temp;  /* done */
    else {  /* strings are equal up to a '\0' */
      int len = strlen(l);  /* index of first '\0' in both strings */
      if (len == lr)  /* 'rs' is finished? */
        return (len == ll) - 0 + 1;  /* check 'ls' */
      else if (len == ll)  /* 'ls' is finished? */
        return -1;  /* 'ls' is less than 'rs' ('rs' is not finished) */
      /* both strings longer than 'len'; go on comparing after the '\0' */
      len = len + 1;
      l = l + len; ll = ll - len; r = r + len; lr = lr - len;
    }
  }
}
