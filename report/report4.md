## lab4 实验报告
本实验已完成所有的必做内容
### 一、编译与测试命令
编译可以使用：
  > make parser（或直接make）

通过makefile提供的方式可以对本实验项目进行编译，生成程序名为parser。
parser有如下两种使用方式：
1. `./parser test.cmm test.s`
   该命令读取输入的源代码文件`test.cmm`，对其编译生成相应的mips汇编代码文件`test.s`
2. `./parser test.cmm test.ir test.s`
   该命令读取输入的源代码文件`test.cmm`，对其编译生成相应的中间代码`test.ir`和mips汇编代码文件`test.s`
### 二、实现过程
该实验的承接实验三中的线性ir数据结构，逐条进行代码翻译，并使用局部寄存器分配算法。

#### 2.1、局部寄存器分配
1. **寄存器分配流程**
    寄存器分配是第一大难点，由于不过分追求性能，我们采用第二种方法。为了记录代码中所有变量的寄存器`reg`和在栈上的保存地址`offset`(与$fp的偏移量)，我们先利用前面实验分析的信息为每个变量分配编号(包括中间变量)：
    ```
    struct var_{
        int reg;
        int offset;
    }varsymbol[num]; //其中前varcnt个位置代表普通变量，之后的tmpcnt个位置代表中间变量
    ```
    在有了上述的结构信息后，当需要为某个变量分配寄存器时，只需采用如下的架构：
    ```
    int reg_allocate(Operand op){
        int varnum = findnum(op);          //获得该变量的编号
        if(varsymbol[varnum].reg!=0) 
            return varsymbol[varnum].reg;  //该变量已有寄存器，直接返回
        for(int i=8;i<26;i++){             //该变量没有寄存器
            if(mipreg[i].free == 0){
                ...
            }
        }
        // 此时没有空闲的寄存器
        for(int i=8;i<26;i++){
            if(i!=use_reg1 && i!=use_reg2){
                reg_spill(i);              //找到一个寄存器，将其中的变量溢出到栈上，然后分配给当前变量
                ...
                return i;
            }}
        return 0;
    }
    ```
    
    有了上面的这些API，我们就可以在代码翻译时为遇到的变量分配寄存器，但需要额外注意的时，当没有空闲寄存器时，我们**不能将同一条代码中的其他变量的溢出**，由于中间代码是三地址代码，所以我们在维护了两个全局变量`use_reg1`和`use_reg2`表示不能将这两个寄存器内的变量溢出。
    
2. **利用基本块信息优化**
   大部分变量的使用仅仅在某个基本块内部（特别是中间变量），所以为了提高性能，当离开一个基本块时会将所有的寄存器溢出，而进入一个新的基本块时将所有寄存器清空，所有寄存器不再被占用，都可用于分配。主要发生在`function`,`label`,`goto`指令处。

#### 2.1、栈信息维护以及函数调用
首先，所有的变量溢出时都会放在栈上，每个变量在栈上的地址通过`var.offset+$fp`的方式计算。
此外，当发生函数调用时，还需维护特殊的栈结构
1. **函数调用**
   当发生函数调用时，先会将所有的寄存器中的变量溢出到栈上，然后再进行参数压栈(前四个参数放在寄存器中)，然后再保存fp和ra等信息。主要模型如下
     |......|
     |------|
     |param4|
     |param5|
     |......|
     |$fp|
     |$ra|
     |......| 
    由于我们以将所有的变量都溢出，所以无需进行调用者保护寄存器和被调用者保护寄存器的压栈出栈操作。

### 三、关键问题解决
**问题1：分支跳转语句会使得栈有不同的表现**
我们通过维护一个全局变量`sp_offset`，来记录sp距fp之间的，从而为变量保存offset信息，那当发生分支判断语句时，由于翻译代码与生成的汇编代码不再同一个时空中，`sp_offset`的值会不断累加。所以对每个分支的两个`label`语句处的`sp_offset`值一样。
